프로젝트 분석 및 개발 계획서

## 1. 분석 개요

본 문서는 제공된 `LabProject` C++ 소스 코드들과 `BinaryHierarchicalModelExtract.cs` 스크립트를 분석하고, 이를 바탕으로 최종 게임 과제 요구사항을 만족시키기 위한 개발 계획을 수립하는 것을 목적으로 한다.

---

## 2. 프로젝트별 특징 분석

각 `LabProject`들은 순차적으로 기능이 확장되는 구조를 가지며, 분석 결과는 다음과 같다.

- **LabProject08-7:**
  - 가장 완성도가 높은 프로젝트로, 지형(HeightMap), 스카이박스, 빌보드(풀, 나무 등) 렌더링 기능이 구현되어 있다.
  - 플레이어와 카메라 시스템이 잘 갖추어져 있어 기능 확장에 용이하다.
  - **결론: 최종 과제 개발을 위한 최적의 기반 프로젝트이다.**

- **LabProject08-5:**
  - `LabProject08-7`의 이전 버전으로, 빌보딩을 사용한 객체 렌더링이 포함되어 있다.

- **LabProject08-1-4:**
  - 지형 렌더링과 텍스처 변환(Lava 효과) 기능이 구현되어 있다.

- **LabProject08-1-3:**
  - 계층적 모델(`.bin`)을 불러오고 렌더링하는 기능에 중점을 둔 프로젝트이다. `CGameObject::LoadGeometryFromFile` 함수를 통해 `.bin` 파일의 복잡한 구조를 파싱한다.

- **LabProject08-0-1:**
  - UI 렌더링을 위한 `UILayer` 클래스가 구현되어 있다. Direct2D와 DirectWrite를 사용하여 텍스트를 렌더링한다.

---

## 3. `.bin` 모델 파일 구조 분석 (BinaryHierarchicalModelExtract.cs 기반)

`.bin` 파일은 Unity에서 `BinaryWriter`를 통해 생성된 바이너리 파일로, 다음과 같은 계층적 구조를 가진다.

- **`<Frame>`:**
  - 게임 오브젝트의 계층 구조(부모-자식-형제)를 나타내는 기본 단위이다.
  - **데이터:** 프레임 이름, 변환 행렬(로컬/월드), 자식 프레임 수, 포함된 메시 및 재질 정보.

- **`<Mesh>`:**
  - 3D 모델의 정점 데이터를 포함한다.
  - **데이터:** 바운딩 박스, 정점 개수, 그리고 각 정점의 위치(`Positions`), 색상(`Colors`), UV좌표(`TextureCoords`), 법선(`Normals`), 탄젠트(`Tangents`), 종법선(`BiTangents`) 배열.
  - **서브메시(`<SubMesh>`):** 하나의 메시는 여러 개의 서브메시로 나뉠 수 있으며, 각 서브메시는 독립된 인덱스 버퍼를 가진다. 이는 모델의 각기 다른 부분에 다른 재질을 적용하기 위함이다.

- **`<Materials>`:**
  - 메시 표면의 재질 정보를 담는다.
  - **데이터:** 재질의 개수, 그리고 각 재질별 색상(Albedo, Emissive, Specular), 표면 속성(Glossiness, Smoothness, Metallic 등), 그리고 아래에 기술된 텍스처 맵들의 파일 이름.

- **텍스처 맵:**
  - 재질에 사용되는 텍스처들의 정보를 담는다. (`<AlbedoMap>`, `<NormalMap>`, `<SpecularMap>` 등)
  - **특징:** 중복되는 텍스처 이름 앞에는 '@' 문자를 붙여, 렌더링 시 리소스를 한 번만 로드하도록 최적화되어 있다.

**결론:** `CGameObject::LoadGeometryFromFile` 함수는 이 구조를 재귀적으로 순회하며 파일 포인터를 이동시켜 데이터를 읽어오고, 이를 통해 게임 내에서 오브젝트 계층 구조를 그대로 복원한다. 이 로직을 활용하여 `Mi24.bin`, `SuperCobra.bin`, `Gunship.bin` 모델을 로드한다.

---

## 4. 최종 과제 요구사항

1.  **시작 화면 및 메뉴:**
    -   A-Z 텍스처 아틀라스를 이용한 텍스트 렌더링.
    -   START, RESUME, QUIT 버튼 기능 구현 및 상태 전환.
2.  **게임 월드:**
    -   플레이어(헬리콥터/탱크/자동차 중 택1), 적, 건물 모델 배치.
    -   노멀 맵을 이용한 조명 계산.
    -   1인칭 시점 플레이어 모델 블렌딩 처리.
    -   지형에 물, 나무, 풀 표현 (빌보드는 기하 셰이더 사용).
    -   건물에 반사 효과 구현.
3.  **UI:** 게임 상태, 점수, 적 위치 등 표시.
4.  **게임 시스템:** 충돌 검사, 절두체 컬링 구현.
5.  **특수 효과:** 폭발 효과 구현.

---

## 5. 최종 개발 계획

**기반 프로젝트:** `LabProject08-7`

**개발 단계:**

1.  **1단계: 프로젝트 재구성 및 모델 로딩 (기반 구축)**
    -   `LabProject08-7`을 `FinalProject`로 복사하여 새 프로젝트를 구성한다.
    -   `LabProject08-1-3`의 모델 로딩 관련 코드(`Object.cpp`, `Mesh.cpp`의 `LoadGeometryFromFile` 등)를 `FinalProject`에 통합한다.
    -   플레이어 객체는 `Mi24.bin`을, 적 객체는 `SuperCobra.bin`과 `Gunship.bin`을 로드하도록 `Scene` 클래스를 수정한다.

2.  **2단계: UI 및 게임 상태 관리 구현**
    -   `CGameFramework`에 `eGameState` 열거형과 상태 변수를 추가하여 게임 상태 머신을 구현한다.
    -   A-Z 텍스처 아틀라스를 기반으로 텍스트를 렌더링하는 `CSpriteFont` 또는 유사 클래스를 구현한다.
    -   START/RESUME/QUIT 버튼 기능을 포함한 UI 상호작용 및 상태 전환 로직을 완성한다.

3.  **3단계: 고급 렌더링 및 월드 확장**
    -   `Shaders.hlsl` 파일을 수정하여 노멀 맵핑을 지원하는 조명 모델을 구현한다.
    -   기하 셰이더(Geometry Shader)를 새로 작성하여 풀, 나무 등 빌보드 객체를 생성 및 렌더링한다.
    -   큐브맵 텍스처를 생성하고, 반사 셰이더를 작성하여 건물에 반사 효과를 적용한다.

4.  **4단계: 게임플레이 시스템 구현**
    -   플레이어(Mi24)의 이동 및 조작 로직을 구현한다.
    -   1인칭 시점에서 플레이어 모델이 반투명하게 보이도록 렌더링 파이프라인의 블렌딩 상태를 설정한다.
    -   객체 간 바운딩 박스(Bounding Box)를 이용한 충돌 검사 로직을 추가한다.
    -   카메라의 절두체(Frustum)를 이용해 화면 밖 객체를 그리지 않는 절두체 컬링을 구현한다.

5.  **5단계: 마무리**
    -   파티클 시스템을 이용한 폭발 효과를 구현한다.
    -   게임 점수, 적 위치 등을 표시하는 최종 UI를 완성한다.

---

## 6. 필요 리소스 목록

### 6.1. 준비된 리소스 (현재 확보)

- **3D 모델 (`.bin`):**
  - `Mi24.bin`: 플레이어 헬리콥터 모델
  - `SuperCobra.bin`: 적 헬리콥터 모델 1
  - `Gunship.bin`: 적 헬리콥터 모델 2
  - `Tree.bin`: 월드 배치용 나무 모델

- **텍스처 (`.dds`):**
  - 각 모델(`Mi24`, `SuperCobra`, `Gunship`)에 포함된 텍스처
  - 지형 텍스처 (`Terrain/Base_Texture.dds`, `Terrain/Detail_Texture_7.dds`)
  - 스카이박스 텍스처 (`Skybox/Skybox_0.dds`)

### 6.2. 준비가 필요한 리소스 (추가 필요)

- **3D 모델 (`.bin`):**
  - **건물 모델:** 게임 월드 구성용.
    - *임시 리소스:* 단순 사각형 박스(`CCubeMeshDiffused`)로 대체 구현합니다.

- **텍스처 및 이미지:**
  - **UI 폰트 텍스처 아틀라스:** UI 텍스트 렌더링용 알파벳 텍스처.
    - *임시 리소스:* DirectWrite를 사용한 표준 폰트 렌더링으로 우선 구현합니다.
  - **물(Water) 텍스처:** 지형의 물 표현용.
    - *임시 리소스:* 단색 또는 간단한 노이즈 텍스처로 대체합니다.
  - **폭발 효과 스프라이트 시트:** 폭발 애니메이션용 텍스처.
    - *임시 리소스:* 단색 파티클이 퍼지는 형태로 구현합니다.
  - **반사 효과용 큐브맵:** 건물 반사용 고품질 환경 맵.
    - *임시 리소스:* 기존 스카이박스 텍스처를 사용하여 기본적인 반사 효과를 구현합니다.

---

## 7. 핵심 데이터 구조 및 렌더링 파이프라인

- **정점 정보 (Vertex Data):**
  - **저장:** `CMesh` 클래스 내의 CPU 메모리 배열에 원본 데이터를 저장한 후, `ID3D12Resource` 형태의 정점 버퍼(Vertex Buffer)와 인덱스 버퍼(Index Buffer)로 GPU 메모리에 업로드됩니다.
  - **사용:** `CMesh::Render()`에서 `IASetVertexBuffers()`와 `IASetIndexBuffer()`를 통해 GPU에 데이터 위치를 알려주고, `DrawIndexedInstanced()`를 호출하여 렌더링합니다.

- **재질 (Material):**
  - **저장:** `CMaterial` 클래스는 렌더링에 필요한 `CShader`와 `CTexture` 객체에 대한 포인터를 가집니다. 즉, '어떤 셰이더'와 '어떤 텍스처'로 그릴지에 대한 '설정값 묶음'입니다.
  - **사용:** `CGameObject`가 렌더링될 때, 자신의 `CMaterial`을 통해 `CTexture::UpdateShaderVariables()`를 호출하여 텍스처를 파이프라인에 바인딩하고, 색상과 같은 재질 속성을 셰이더로 전달합니다.

- **셰이더 (Shader):**
  - **저장:** `CShader` 클래스는 컴파일된 셰이더 코드(`.hlsl`)와 렌더링 상태(블렌딩, 깊이 테스트 등)를 포함하는 **PSO(Pipeline State Object)**를 `ID3D12PipelineState` 객체로 관리합니다.
  - **사용:** `CGameObject`가 렌더링될 때, 재질(`CMaterial`)에 연결된 `CShader`의 `Render()` 함수가 호출됩니다. 이 함수는 `SetPipelineState()`를 통해 GPU가 앞으로 그릴 객체에 어떤 셰이더 프로그램과 렌더링 규칙을 적용할지 결정합니다.

- **객체 (GameObject) 및 렌더링 흐름:**
  1. `CGameFramework`의 메인 루프가 `CScene::Render()`를 호출합니다.
  2. `CScene`은 자신의 모든 `CGameObject`들의 `Render()` 함수를 순차적으로 호출합니다.
  3. `CGameObject::Render()` 함수는 다음을 수행합니다.
     a. 자신의 월드 변환 행렬을 계산하고 셰이더에 전달합니다.
     b. 자신이 가진 `CMaterial`을 통해 **PSO(셰이더)**와 **텍스처**를 렌더링 파이프라인에 설정합니다.
     c. 자신이 가진 `CMesh`의 `Render()` 함수를 호출하여 **정점/인덱스 버퍼**를 파이프라인에 설정하고 최종 `Draw` 명령을 내립니다.
     d. 자신의 자식(`m_pChild`) 및 형제(`m_pSibling`) 객체의 `Render()` 함수를 재귀적으로 호출하여 전체 계층 구조를 렌더링합니다.