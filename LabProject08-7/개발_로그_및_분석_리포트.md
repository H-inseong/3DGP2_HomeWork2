# 3D 게임 프로젝트 개발 로그 및 분석 리포트

## 1. 최종 요약 및 현재 상태

현재 프로젝트는 수많은 D3D12 API 관련 오류와 데이터 흐름 문제를 해결하고, 마침내 **폰트 렌더링 기능 구현에 성공**한 상태입니다. 이제 화면에 원하는 텍스트를 출력할 수 있는 안정적인 기반이 마련되었습니다.

### 현재 폰트 렌더링 시스템 아키텍처
- **렌더링 파이프라인:** C++(`DrawString`)에서 각 문자 당 1개의 정점(Point)을 생성하여 GPU로 전달하면, Geometry Shader가 이를 4개의 정점(Quad)으로 확장하여 최종적으로 문자를 그리는 효율적인 방식을 사용합니다.
- **데이터 흐름:**
    1.  **정점 버퍼 (Vertex Buffer):** `DrawString` 함수가 호출될 때마다, 출력할 문자열에 대한 정점 데이터(`위치`, `색상`, `문자 ID`)가 동적으로 채워집니다.
    2.  **구조화된 버퍼 (Structured Buffer):** `D2coding.fnt` 파일에서 읽어온 128개 문자의 상세 정보(`CharInfo` 배열)가 담겨 있으며, Geometry Shader가 문자의 형태를 만들 때 참조합니다. (셰이더 레지스터 `t1`)
    3.  **상수 버퍼 (Constant Buffer):** 렌더링에 필요한 전역 정보(`ScreenSize`, `TextureSize`, `Scale`, `FontColor` 등)가 담겨 있으며, `RenderUI` 함수에서 매 프레임 업데이트됩니다. (셰이더 레지스터 `b0`)

### **가장 중요한 다음 과제: 메모리 누수 해결**
현재 폰트 기능은 정상 작동하지만, 프로그램 전체적으로 **심각한 리소스 누수 문제**가 남아있습니다. 이 문제는 이전에 겪었던 `DEVICE_REMOVAL` 오류의 근본 원인이며, 해결하지 않으면 향후 다른 기능을 추가할 때 예측 불가능한 충돌을 계속 유발할 것입니다. **프로젝트의 안정성을 위해 이 문제를 해결하는 것이 최우선 과제입니다.**

---

## 2. 주요 버그 및 해결 과정 로그

지금까지 다음과 같은 주요 버그들을 해결했습니다.

### 버그 1: `DEVICE_REMOVAL_PROCESS_AT_FAULT` (디바이스 제거 오류)
- **증상:** `CreateCommittedResource` 등 D3D12 API 호출 시 간헐적으로 프로그램이 충돌하며 디바이스 제거 오류 발생.
- **원인:** `CGameFramework`의 소멸자(`~CGameFramework`)가 비어있고, 수동으로 호출하는 `OnDestroy()`와 `ReleaseObjects()` 함수에서 대부분의 게임 객체들(`CSpriteFont`, `CScene` 등)을 `delete`하지 않아, 프로그램 종료 시 D3D12 리소스가 대량으로 누수됨. 이로 인해 그래픽 드라이버 상태가 불안정해져 다음 실행 시 충돌 발생.
- **상태:** 원인 분석 완료. **아직 코드는 수정되지 않음.** (향후 계획 참조)

### 버그 2: `SET_VERTEX_BUFFERS_INVALID` (정점 버퍼 설정 오류)
- **증상:** `IASetVertexBuffers` 호출 시 버퍼 크기가 리소스 범위를 초과한다는 오류 발생.
- **원인:** `CSpriteFont` 생성자에서 정점 버퍼를 생성할 때, **정점 1개** 크기로 버퍼를 생성하고, 버퍼 뷰(View)는 **최대 문자 개수(128개)** 크기로 정의하여 불일치 발생.
- **해결:** 정점 버퍼 생성 시 `sizeof(FONT_VERTEX) * m_MAX_CHARS` 크기로 할당하여 버퍼와 뷰의 크기를 일치시킴.

### 버그 3: `E_INVALIDARG` on `CreateGraphicsPipelineState` (PSO 생성 오류)
- **증상:** 폰트 렌더링용 PSO 생성 시 `E_INVALIDARG` 오류 발생.
- **원인:** C++의 Input Layout(`InputElementDesc`) 정의와 HLSL 셰이더의 정점 입력(`VS_INPUT`) 구조체 정의가 불일치. C++에서는 `TYPE` 시맨틱을 `float2`로 정의했으나, HLSL에서는 `uint`로 기대하고 있었음.
- **해결:** `GameFramework.cpp`의 `InputElementDesc`에서 `TYPE`의 포맷을 `DXGI_FORMAT_R32_UINT`로 수정하고, `POSITION`의 철자 오류("POSTION")를 수정함.

### 버그 4: `SET_DESCRIPTOR_TABLE_INVALID` (디스크립터 힙 오류)
- **증상:** `SetGraphicsRootDescriptorTable` 호출 시, 현재 설정된 힙과 다른 힙의 핸들을 사용한다는 오류 발생.
- **원인:** 복합적.
    1.  폰트 렌더링에 3개의 디스크립터가 필요한데, 힙의 크기를 2로 생성함.
    2.  3번째 슬롯에 들어갈 상수 버퍼 뷰(CBV)를 생성하는 코드가 누락됨.
    3.  `RenderUI` 함수에서 `SetGraphicsRootDescriptorTable` 호출이 누락됨.
- **해결:** 힙 크기를 3으로 늘리고, `BuildFont`에서 CBV를 생성하여 3번째 슬롯에 저장하도록 수정. `RenderUI`에서 3개의 모든 테이블을 설정하도록 코드 추가.

### 버그 5: `DrawString` 반복문 진입 불가 (조건문 오버플로우)
- **증상:** `DrawString`의 `for` 루프에 중단점을 걸어도 진입하지 않음.
- **원인:** `if (c >= static_cast<char>(m_vCharInfos.size()))` 조건문에서 `size()`가 128일 때 `static_cast<char>(128)`이 `signed char`의 범위를 넘어 오버플로우가 발생, `-128`로 변환됨. 이로 인해 `c >= -128` 조건이 항상 참이 되어 `continue`가 실행됨.
- **해결:** `if (static_cast<unsigned char>(c) >= m_vCharInfos.size())`로 수정하여, `c`를 부호 없는 정수로 안전하게 비교하도록 변경.

### 버그 6: 화면에 글자 안 나옴 (데이터 흐름 오류)
- **증상:** 모든 API 오류 해결 후에도 화면에 아무것도 그려지지 않음.
- **원인:** Geometry Shader가 좌표 변환에 사용하는 `ScreenSize` 값이 상수 버퍼를 통해 전달되지 않음. 또한 `CGameFramework`와 `CSpriteFont`에 각각 상수 버퍼가 중복으로 존재하여 데이터 업데이트가 꼬이는 문제가 있었음.
- **해결:** `RenderUI` 함수에서 셰이더가 실제로 사용하는 `CGameFramework`의 상수 버퍼(`m_pcbMappedFont`)에 `ScreenSize`, `TextureSize` 등 모든 필수 정보를 업데이트하도록 로직을 통합함.

---

## 3. 향후 계획

### 3.1. 즉시 해결할 과제: 리소스 누수 문제 해결

프로젝트의 안정성을 위해 아래 3단계 작업을 통해 자원 관리 구조를 개선해야 합니다.

**1. `CGameFramework::ReleaseObjects()` 함수 수정:**
`GameFramework.cpp`의 해당 함수를 아래 코드로 교체하여 모든 동적 할당된 객체가 `delete` 되도록 합니다.
```cpp
void CGameFramework::ReleaseObjects()
{
	ReleaseShaderVariables();

	if (m_pPlayer) delete m_pPlayer;
	m_pPlayer = nullptr;

	if (m_pSpriteFont) delete m_pSpriteFont;
	m_pSpriteFont = nullptr;

	// m_vScenes 벡터에 있는 모든 Scene 객체를 순회하며 삭제
	for (auto pScene : m_vScenes)
	{
		if (pScene) pScene->ReleaseObjects();
		if (pScene) delete pScene;
	}
	m_vScenes.clear(); // 벡터 자체를 비움

	// m_pScene은 m_vScenes의 원소를 가리키므로, 포인터만 nullptr로 설정
	if (m_pScene) m_pScene = nullptr;
}
```

**2. `OnDestroy` 로직을 소멸자로 이동:**
`GameFramework.cpp`의 `void CGameFramework::OnDestroy()` 함수의 모든 내용을 `CGameFramework::~CGameFramework()` (소멸자) 안으로 옮깁니다.

**3. `_tWinMain`에서 `OnDestroy` 호출 제거:**
`LabProject08-7.cpp`의 `_tWinMain` 함수 마지막에 있는 `gGameFramework.OnDestroy();` 라인을 삭제합니다.

### 3.2. 장기 계획
위의 안정성 문제가 해결되면, 원래의 프로젝트 목표였던 다음 기능들을 구현할 수 있습니다.
- 계층적 모델(`Mi24.bin` 등) 렌더링
- 노멀 맵핑, 반사 효과 적용
- 빌보딩 구현
- 충돌 처리 시스템 구현
