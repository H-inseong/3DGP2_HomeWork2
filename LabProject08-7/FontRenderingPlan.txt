## Font Rendering Plan

This file documents the plan for implementing font rendering in the DirectX 12 project.

### 1. HLSL Shader Code (`Font.hlsl`)

The following HLSL code defines the vertex, geometry, and pixel shaders for rendering text. The geometry shader is used to generate character quads from points, which is an efficient approach.

```hlsl
// Font.hlsl

struct VS_INPUT
{
	float2 Position : POSITION;
	float4 Color : COLOR; // This color will be passed to the GS
	uint Type : TYPE;     // Index into the CharInfo structured buffer
};

struct GS_INPUT
{
	float4 Position : SV_POSITION; // screen space position (x,y is top-left char position)
	float4 Color : COLOR; // Character color
	uint Type : TYPE;     // Index into the CharInfo structured buffer
};

struct PS_INPUT
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD;
	float4 Color : COLOR;
};

// Font texture (DDS file)
Texture2D gtxtFont : register(t0);
SamplerState gSampler : register(s0);

// Constant buffer for font rendering parameters
cbuffer cbFontInfo : register(b0)
{
	float4 g_v4FontColor;  // Overall font color modulation
	float2 g_v2ScreenDim;  // Screen dimensions (e.g., width, height) for UV normalization and scaling
	float  g_fScale;       // Overall scale factor for text
	float2 g_v2CurrentPenPos; // Current pen position for drawing (relative to top-left of screen)
};

// Character information from the .fnt file
struct CharInfo
{
	int id;
	int x, y;          // Top-left pixel coordinates in the texture
	int width, height; // Dimensions in the texture
	int xoffset, yoffset; // Offset from current cursor position to placement of glyph
	int xadvance;      // How much to advance the cursor for next character
	int page;          // Texture page (if multiple textures exist, we only use one for now)
	int chnl;
};

// Structured buffer containing character information for the current string being drawn
StructuredBuffer<CharInfo> gCharInfos : register(t1);

GS_INPUT VS_Font(VS_INPUT In)
{
	GS_INPUT Out = (GS_INPUT)0;
	// Convert input position (which is likely in screen coordinates) to clip space or similar
	// For now, assume In.Position is already in a manipulable screen-space (e.g., pixel coordinates)
	// We'll let the GS handle the conversion to clip space.
	Out.Position = float4(In.Position, 0.0, 1.0);
	Out.Color = In.Color;
	Out.Type = In.Type;
	return Out;
}

[maxvertexcount(4)] // A geometry shader outputting a quad (4 vertices)
void GS_Font(point GS_INPUT In[1], inout TriangleStream<PS_INPUT> OutStream)
{
	// Get character info from the structured buffer using the 'Type' as index
	CharInfo charInfo = gCharInfos[In[0].Type];

	// Calculate the actual size of the character glyph on screen
	// Apply overall scale as well
	float2 glyphSize = float2(charInfo.width, charInfo.height) * g_fScale;
	// Apply individual character offset
	float2 glyphOffset = float2(charInfo.xoffset, charInfo.yoffset) * g_fScale;

	// Calculate the final top-left position of the glyph based on the pen position and character offset
	// The In[0].Position.xy comes from the pen position, not necessarily a character's top-left.
	// Adjust it according to the current pen position plus the character's unique offset.
	float2 screenPosTL = In[0].Position.xy + glyphOffset;

	// Calculate the four corner positions of the glyph quad in screen space (pixel coordinates)
	float2 positions[4];
	positions[0] = screenPosTL;                                  // Top-Left
	positions[1] = float2(screenPosTL.x + glyphSize.x, screenPosTL.y); // Top-Right
	positions[2] = float2(screenPosTL.x, screenPosTL.y + glyphSize.y); // Bottom-Left
	positions[3] = screenPosTL + glyphSize;                        // Bottom-Right

	// Calculate UV coordinates directly from CharInfo using the texture's dimensions (g_v2ScreenDim acts as texture dimensions here)
	float2 uv_top_left     = float2(charInfo.x, charInfo.y) / g_v2ScreenDim;
	float2 uv_top_right    = float2(charInfo.x + charInfo.width, charInfo.y) / g_v2ScreenDim;
	float2 uv_bottom_left  = float2(charInfo.x, charInfo.y + charInfo.height) / g_v2ScreenDim;
	float2 uv_bottom_right = float2(charInfo.x + charInfo.width, charInfo.y + charInfo.height) / g_v2ScreenDim;

	PS_INPUT Out;
	Out.Color = In[0].Color * g_v4FontColor; // Modulate vertex color with global font color

	// Helper to convert screen pixel coordinates to Normalized Device Coordinates (NDC)
	// Assuming a screen space of (0,0) at top-left and (width, height) at bottom-right
	float4 ScreenToClip(float2 screenCoord, float2 screenDims)
	{
		// Convert to [0,1] range
		float2 normalized = screenCoord / screenDims;
		// Convert to [-1,1] range (NDC)
		// X: -1 (left) to 1 (right)
		// Y: 1 (top) to -1 (bottom) (DirectX convention for screen Y)
		float2 clipXY;
		clipXY.x = normalized.x * 2.0f - 1.0f;
		clipXY.y = (1.0f - normalized.y) * 2.0f - 1.0f; // Invert Y for DirectX
		return float4(clipXY, 0.0f, 1.0f);
	}

	// Emit vertices for the quad as a triangle strip
	// Vertex 0: Top-Left
	Out.Position = ScreenToClip(positions[0], g_v2ScreenDim);
	Out.UV = uv_top_left;
	OutStream.Append(Out);

	// Vertex 1: Top-Right
	Out.Position = ScreenToClip(positions[1], g_v2ScreenDim);
	Out.UV = uv_top_right;
	OutStream.Append(Out);

	// Vertex 2: Bottom-Left
	Out.Position = ScreenToClip(positions[2], g_v2ScreenDim);
	Out.UV = uv_bottom_left;
	OutStream.Append(Out);

	// Vertex 3: Bottom-Right
	Out.Position = ScreenToClip(positions[3], g_v2ScreenDim);
	Out.UV = uv_bottom_right;
	OutStream.Append(Out);

	OutStream.RestartStrip(); // End of the current primitive
}

float4 PS_Font(PS_INPUT In) : SV_TARGET
{
	// Sample the font texture
	float4 fontTexel = gtxtFont.Sample(gSampler, In.UV);
	// The font texture typically stores alpha in one channel (e.g., red or alpha channel itself).
	// For most distance field fonts, the alpha channel is the one we care about.
	// For traditional bitmap fonts, it might be grayscale or actual RGBA.
	// Assuming it's a grayscale font where brightness corresponds to opacity, or alpha is in RGB.
	// If it's a single-channel alpha texture, we effectively use that as alpha for our color.
	// If it's a standard RGBA image, we multiply the color.

	// A common practice for monochrome fonts is to store alpha in one channel, e.g., the red channel for a grayscale DDS.
	// Here, we take the sampled alpha and multiply it with the incoming vertex color.
	// This allows for colored text with an alpha-masked font.
	// You might need to adjust `fontTexel.a` to `fontTexel.r` or another channel depending on your font texture format.
	return float4(In.Color.rgb, fontTexel.a * In.Color.a);
}
```

### 2. Next Steps for C++ Integration

1.  **Create DirectX 12 Root Signature:**
    *   Define and create a root signature in `CGameFramework` or `CScene` that describes the resources used by the shader (font texture SRV, `CharInfo` Structured Buffer SRV, and the `cbFontInfo` constant buffer).
    *   This requires adding a CBV/SRV/UAV descriptor heap to `CGameFramework` to hold the SRVs for the font texture and the structured buffer.

2.  **Create Pipeline State Object (PSO):**
    *   Create a PSO that links the `Font.hlsl` shaders (VS, GS, PS) with the new root signature.
    *   This PSO must be configured for 2D rendering with appropriate blend states (for alpha blending), rasterizer states (e.g., no culling), and depth-stencil states (e.g., depth testing/writing disabled).

3.  **Implement `CSpriteFont::DrawString`:**
    *   Ensure the `CharInfo` struct in `Font.h` matches the one in the shader.
    *   The function should:
        *   Upload the `CharInfo` data for the input string to a temporary Structured Buffer.
        *   Set the font rendering PSO and root signature.
        *   Bind the SRVs for the font texture and the `CharInfo` buffer.
        *   Update and bind the `cbFontInfo` constant buffer with color, screen dimensions, scale, and pen position.
        *   Create and bind a vertex buffer containing a single point (`VS_INPUT`) for each character.
        *   Call `Draw()` for each character.
